package errs

import (
	"fmt"
	"regexp"
)

type frameSkip int8

const (
	maybeSkip frameSkip = iota
	mustSkip            = iota
	noSkip              = iota
)

// FrameSkipper handles the frame skipping logic.
type FrameSkipper struct {
	active      bool
	skippingNum int
}

// NewFrameSkipper creates a new frame skipper.
func NewFrameSkipper(lastFrameFilePath string) *FrameSkipper {
	if shouldSkipPrintingFrame(lastFrameFilePath) != noSkip {
		return &FrameSkipper{active: false}
	}
	return &FrameSkipper{active: true}
}

// ShouldSkip determines whether the given frame should be skipped, it assume the caller call
// this from the deepest frame first.
func (s *FrameSkipper) ShouldSkip(filepath string) bool {
	if !s.active {
		return false
	}
	skip := shouldSkipPrintingFrame(filepath)
	switch skip {
	case noSkip:
		s.skippingNum = -1
		return false
	case mustSkip:
		if s.skippingNum < 0 {
			s.skippingNum = 1
		} else {
			s.skippingNum++
		}
		return true
	case maybeSkip:
		if s.skippingNum < 0 {
			return false
		}
		s.skippingNum++
		return true
	}
	panic(fmt.Sprint("impossible ", skip))
}

var mustSkipPattern = regexp.MustCompile(
	`/negroni/` +
		`|/graphql-go/graphql/` +
		`|/godataloader/` +
		`|/httpserv/[^/]+$`)

var maybeSkipPattern = regexp.MustCompile(
	`<autogenerated>` +
		`|net/http/` +
		`|/mux/` +
		`|reflect/` +
		`|/lu/` +
		`|runtime/` +
		`|/backend/gql/[^/]+\.go`)

// shouldSkipPrintingFrame allows skip printing middleware frame.
func shouldSkipPrintingFrame(f string) frameSkip {
	// The following logic is a2 specific.
	if mustSkipPattern.MatchString(f) {
		return mustSkip
	}
	if maybeSkipPattern.MatchString(f) {
		return maybeSkip
	}
	return noSkip
}
